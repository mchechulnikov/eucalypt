# Eucalypt
Script execution by HTTP. Currently only .NET/C# is supported

## About
* [Ktor](https://ktor.io) for HTTP server
* [Koin](https://insert-koin.io) for dependency injection
* Script runners – a.k.a. executors – are [Docker](https://www.docker.com) containers with memory, CPU restrictions and network isolation. Also [TMPFS](https://en.wikipedia.org/wiki/Tmpfs) used instead of real filesystem
* Containers ran from pre-build images located `./src/src/images`
* Executres united in pool. It's is able to automaticaly extend and shink it's own size, detects hanged executors and re-run them

## How to run
### Before
You need
* Docker
* Gradle
* GNU Make
* curl
* IntelliJ IDEA

It has been written and tested on MacBook Pro (14-inch, 2021) Apple M1 Pro, RAM 32 GB via IntelliJ IDEA 2021.3.3 (Ultimate Edition).

⚠️ Before first run you must build executos images
```
make build.images
```

### Run
Since project was generated by Ktor template I always ran IntelliJ IDEA.<br/>
### Run tests
To run tests you can also use
```
cd ./src
gradle test
```
or again just run from IntelliJ IDEA.

#### Coverage
There are 69 unit tests on logic and 1 integrational test for main happy path. Used JUnit 5 + [mockk](https://mockk.io)
![scr](docs/coverage.png)

### Try
Check some examples in `./examples` directory. You can easly CURL it via makefile. <br/>
To print available tasks
```
make
```

To build executors' images
```
make build.images
```

To run example first of all run server and then make
```
make dotnet.hw      # hello world!
make dotnet.fib     # Fibonacci numbers up to 42
make dotnet.fio     # writes some lines to file and reads it
make dotnet.inf     # infinity operation: aborted by timeout and prints stdout
make dotnet.inv     # invalid code that doesn't compile
```

For example:
```
❯ make dotnet.hw
> Executing on .NET SDK 6.0
> Resources: CPU 1.5, RAM 100 MB, space 100 MB, network - false

> Output:

Hello World!

------------------------------
✓ Script executed successfully
> Time elapsed: 2 seconds
```
```
❯ make dotnet.inv
> Executing on .NET SDK 6.0
> Resources: CPU 1.5, RAM 100 MB, space 100 MB, network - false

> Output:

Microsoft (R) Build Engine version 17.1.0+ae57d105c for .NET
Copyright (C) Microsoft Corporation. All rights reserved.

/exec-dir/Program.cs(9,29): error CS1002: ; expected [/exec-dir/Main.csproj]

Build FAILED.

/exec-dir/Program.cs(9,29): error CS1002: ; expected [/exec-dir/Main.csproj]
    0 Warning(s)
    1 Error(s)

Time Elapsed 00:00:00.85

------------------------------
✓ Script executed successfully
> Time elapsed: 1 seconds
```
```
❯ make dotnet.inf
> Executing on .NET SDK 6.0
> Resources: CPU 1.5, RAM 100 MB, space 100 MB, network - false

> Output:

Running...
Running...
Running...

----------------------------------------------------
✗ Script running timeout exceeded. Execution aborted
> Time elapsed: 10 seconds
```



## Architecture
### Data flow
``` mermaid
graph LR
    Client -- HTTP POST --> Server

    subgraph Server side
        Server["Eucalypt server <br/> [Kotlin, Ktor]"]

        Server --> Executor1
        Server --> Executor2

        subgraph "Pool of executors"
            subgraph "Container 1"
                Executor1["Executor <br/> [.NET CLI]"]
            end

            subgraph "Container 2"
                Executor2["Executor <br/> [.NET CLI]"]
            end
        end
    end

    Internet((Internet))

    Executor1 -. no access .- Internet
    Executor2 -. no access .- Internet


```

### Contol
``` mermaid
graph TB
    subgraph Eucalypt app
        HTTPServer["HTTPServer <br/><br/> Serve HTTP requests"]:::Code
        ScriptRunner["Script runner <br/><br/> - run script on <br/> borrowed executor"]:::Code
        ExecutorsManager["ExecutorsManager <br/> <br/> - borrows executor <br/> - returns (redeem) executor"]:::Code
        ExecutorsPool["ExecutorsPool <br/><br/> - returns available executors <br/> - auto extend/shrink <br/> - monitor state and eliminate hanged <br/> - reserve executor for run safely "]:::Code
        Executor["Executor <br/><br/>- executes scripts <br/> - manages underlying container <br/> - can be reserved for safe execution"]:::Code
        DockerEventsMonitor["DockerEventsMonitor <br/><br/> - monitors containers events <br/> - invoke registered callbacks <br/> for every event"]:::Code
        DockerContainer["DockerContainer <br/><br/> - provides basic control <br/> - reflect current containers state"]:::Code
        DockerOperator["DockerOperator <br/><br/> - run container <br/> - re-run container <br/> - remove container <br/> - monitor Docker events"]:::Code
        

        HTTPServer --> ScriptRunner -- borrow executor --> ExecutorsManager
        ExecutorsManager -- get available --> ExecutorsPool
        ScriptRunner -- execute --> Executor
        ExecutorsPool -- manage --> Executor
        ExecutorsManager -- reserve --> Executor
        Executor -- contol --> DockerContainer
        DockerContainer -. sync state .-> Executor
        DockerContainer -- subscribe --> DockerEventsMonitor
        DockerEventsMonitor -. invoke callback to udapte state .-> DockerContainer
        DockerEventsMonitor -- listen events --> DockerOperator
        DockerContainer -- contol --> DockerOperator
    end

    classDef Code fill: white, stroke: black
    classDef Pool fill: white, stroke: black, stroke-dasharray: 5 5
```

## Scenarious
### Happy path
``` mermaid
sequenceDiagram
    actor User

    User ->> HTTP Handler: execute sctipt
    activate HTTP Handler
        HTTP Handler ->> HTTP Handler: wrap request to task

        HTTP Handler ->> Task Runner: run task
        activate Task Runner
            Task Runner ->> Pool Manager: get executor
            activate Pool Manager
                Pool Manager ->> Pool Manager: are there any ready executors?
                alt THERE ARE!
                    Pool Manager ->> Pool Manager: reserve executor by ID
                else THERE AREN'T!
                    Pool Manager ->> Pool Manager: register new executor ID

                    Pool Manager ->> Pool: extend pool
                    activate Pool
                        Pool -->> Pool Manager: executor added!
                    deactivate Pool

                    Pool Manager ->> Pool Manager: reserve executor by ID
                end
                
                Pool Manager -->> Task Runner: return reserved executor ID
            deactivate Pool Manager

            Task Runner ->> Pool: execute
            activate Pool
                Pool -->> Task Runner: result
            deactivate Pool

            Task Runner -) Pool Manager: ASYNC return used executor
            
            Task Runner -->> HTTP Handler: task result
            note right of Task Runner: immediately return result
        deactivate Task Runner

        HTTP Handler -->> User: script result
    deactivate HTTP Handler
```

### Timeout of execution
``` mermaid
sequenceDiagram
    actor User

    User ->> HTTP Handler: execute sctipt
    activate HTTP Handler
        HTTP Handler ->> HTTP Handler: wrap request to task

        HTTP Handler ->> Task Runner: run task
        activate Task Runner
            Task Runner ->> Pool Manager: get executor
            activate Pool Manager
                Pool Manager -->> Task Runner: return reserved executor
            deactivate Pool Manager

            Task Runner ->> Pool: execute
            activate Pool
                alt SUCCESS
                    Pool -->> Task Runner: result
                    Task Runner -) Pool Manager: ASYNC return used executor
                else TIMEOUT
                    note right of Task Runner: timeout detected
                    Task Runner -) Pool Manager: ASYNC reset executor
                end
            deactivate Pool

            Task Runner -->> HTTP Handler: task result
            note right of Task Runner: immediately return result
        deactivate Task Runner

        HTTP Handler -->> User: script result
    deactivate HTTP Handler
```

### Pool management processes
Executors have several states:
* NEW – just created; should be checked for readiness
* READY – ready for execution
* RESERVED – locked for specific task; state can be changed only by original task or can be killed by double timeout
* EXECUTING – in the middle of execution; can be killed by timeout
* RELEASED – unlocked by task; should be reset
* RESET – in the middle of reset
* ELIMINATED – marked for elimination; should be destoryed

``` mermaid
stateDiagram-v2
    %% creating
    [*] --> NEW: register new
    NEW --> READY: enable

    %% execution
    READY --> RESERVED: borrow for execution
    RESERVED --> EXECUTING: start execution
    EXECUTING --> RELEASED: success
    RELEASED --> RESET: reset 

    %% execution not started or starvation
    RESERVED --> RESET: double timeout
    EXECUTING --> RESET: timeout
    
    %% reset
    RESET --> READY: enable

    %% elimination
    READY --> ELIMINATED: shrink pool size
    ELIMINATED --> [*]: destroy
```

#### Executor creating
``` mermaid
sequenceDiagram
    activate Pool Manager
        Pool Manager ->> Pool Manager: register executor
        note right of Pool Manager: state of executor is CREATED

        Pool Manager ->> Pool: create container
        activate Pool
            Pool -->> Pool Manager: command executed
        deactivate Pool

        loop poll every N ms
            Pool Manager ->> Pool: check if container in ready state
            activate Pool
        end

        Pool -->> Pool Manager: container is ready!
        deactivate Pool

        Pool Manager ->> Pool Manager: enable executor
        note right of Pool Manager: state of executor is READY

    deactivate Pool Manager
```

#### Release and reset executor
``` mermaid
sequenceDiagram
    note right of Task Runner: ...
    Task Runner -) Pool Manager: ASYNC return used executor
    activate Pool Manager
        Pool Manager ->> Pool Manager: release executor
        note right of Pool Manager: state of executor is RELEASED
    deactivate Pool Manager

    note right of Pool Manager: force to start reset operation
    activate Pool Manager
        Pool Manager ->> Pool Manager: reset executor
        note right of Pool Manager: state of executor is RESET

        Pool Manager ->> Pool: reset executor
        activate Pool
            Pool -->> Pool Manager: command executed
        deactivate Pool

        loop poll every N ms
            Pool Manager ->> Pool: check if container in ready state
            activate Pool
        end

        Pool -->> Pool Manager: container is ready!
        deactivate Pool

        Pool Manager ->> Pool Manager: enable executor for further executions
        note right of Pool Manager: state of executor is READY
    deactivate Pool Manager
```

## What's next?
* Configuration files instead of hard-coded `Config` object to configure withour rebuild
* WebSockets to consume running script output line-by-line. That makes execution more interactive for end user
* Containerize server. This require some changes: operating containers from another container has some difficulties and requires paradigm changing. But in this case I'd prefer to delegate pool management to orchestration tool like [Kubernates](https://kubernetes.io)
* Run pool on several hosts. Again, it will be reasonable to consider using container orchestrator for that
* To achieve a posibility to use NuGet it's necessesary: 1) to provide list of packages; 2) make new type of executor with availability to use network by specific URL; 3) Docker network configuration management
* Support other languanges. Just add executors and wire it up with HTTP interface
